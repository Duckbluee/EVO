{"abstract":"\n Given a data set\n D\n containing millions of data points and a data consumer who is willing to pay for $\n X\n to train a machine learning (ML) model over\n D\n ,\n how should we distribute this $X to each data point to reflect its \"value\"?\n In this paper, we define the \"relative value of data\" via the Shapley value, as it uniquely possesses properties with appealing real-world interpretations, such as fairness, rationality and decentralizability. For general, bounded utility functions, the Shapley value is known to be challenging to compute: to get Shapley values for all\n N\n data points, it requires\n O\n (2\n \n N\n \n ) model evaluations for exact computation and\n O\n (\n N\n log\n N\n ) for (\n ϵ\n , δ)-approximation.\n \n \n In this paper, we focus on one popular family of ML models relying on\n K\n -nearest neighbors (\n K\n NN). The most surprising result is that for unweighted\n K\n NN classifiers and regressors, the Shapley value of all\n N\n data points can be computed,\n exactly\n , in\n O\n (\n N\n log\n N\n ) time - an exponential improvement on computational complexity! Moreover, for (\n ϵ\n , δ)-approximation, we are able to develop an algorithm based on Locality Sensitive Hashing (LSH) with only sublinear complexity\n O\n (\n N\n \n h\n (\n ϵ\n ,\n K\n )\n \n log\n N\n ) when\n ϵ\n is not too small and\n K\n is not too large. We empirically evaluate our algorithms on up to 10 million data points and even our\n exact\n algorithm is up to three orders of magnitude faster than the baseline approximation algorithm. The LSH-based approximation algorithm can accelerate the value calculation process even further.\n \n \n We then extend our algorithm to other scenarios such as (1) weighed\n K\n NN classifiers, (2) different data points are clustered by different\n data curators\n , and (3) there are\n data analysts\n providing computation who also requires proper valuation.\n Some\n of these extensions, although also being improved exponentially, are less practical for exact computation (e.g.,\n O\n (\n \n N\n K\n \n ) complexity for weigthed\n K\n NN). We thus propose an Monte Carlo approximation algorithm, which is\n O\n (\n N\n (log\n N\n )\n 2\n /(log\n K\n )\n 2\n ) times more efficient than the baseline approximation algorithm.\n"}